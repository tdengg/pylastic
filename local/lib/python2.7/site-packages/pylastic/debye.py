import json
import numpy as np
from scipy.optimize import fmin
class Debye():
    
    def __init__(self, path='./'):
        self.__kb=1.
        self.__path = path
    
    def get_Cij(self, outfile='/Cij_0.json'):
        f=open(self.__path + outfile)
        self.__Cij_dic = json.load(f)
        f.close()
        return self.__Cij_dic
        
    def calculate_moduli(self, scale):
        Cij_V = self.__Cij_dic[scale]['SM']
        C = np.zeros((6,6))
        for j in range(6):
            for i in range(6):
                C[i,j] = Cij_V[i+6*j]
        BV = (C[0,0]+C[1,1]+C[2,2]+2*(C[0,1]+C[0,2]+C[1,2]))/9
        GV = ((C[0,0]+C[1,1]+C[2,2])-(C[0,1]+C[0,2]+C[1,2])+3*(C[3,3]+C[4,4]+C[5,5]))/15
        EV = (9*BV*GV)/(3*BV+GV)
        self.__GoB = GV/BV
        self.__EoB = EV/BV
        self.__B = BV
        return BV, GV/BV, EV/BV
    
    def debye_function(self, x):
        if x == 0: D=1.
        elif 0 < x <= 0.1:
            D = 1 - 0.375*x + x**2.*(0.05-5.952380953*10**(-4.)*x**2.)
        elif 0.1 < x <= 7.25:
            D = ( (((0.0946173*x-4.432582)*x+85.07724)*x-800.6087)*x+3953.632 ) / ( (((x+15.121491)*x+143.155337)*x+682.0012)*x+3953.632 )
        elif x > 7.25:
            N=int(25./x)
            
            D=0.
            D2=1.
            
            
            if x <= 25.:
                for i in range(1,N+1):
                    
                    DS = i
                    
                    x3 = DS*x
                    D2 = D2*np.exp(-x)
                    D = D + D2*( 6. + x3*(6. + x3*(3.+x3)) )/DS**4.
                D=D/(9.)
                    
            else:
                
                D = 3.*(6.493939402-D)/(x**3.)
        
        return D
    
    
    def debye_T(self, x):
        
        self.__EoB = []
        self.__GoB = []
        self.__B = []
        self.__V = []
        
        dic = self.get_Cij()
        for scale in sorted(dic.keys()):
            (a, b, c) = self.calculate_moduli(scale)
            self.__EoB.append(c)
            self.__GoB.append(b)
            self.__B.append(a)
            self.__V.append(float(scale)**3./2.)
        
        
        c1= np.polyfit(self.__V, self.__EoB, 4)
        p_EoB = np.poly1d(c1)
           
        c2= np.polyfit(self.__V, self.__GoB, 4)
        p_GoB = np.poly1d(c2)
        
        c3= np.polyfit(self.__V, self.__B, 4)
        p_B = np.poly1d(c3)

        Const = 1.
        theta = Const * ( 1./3.*(p_EoB(x))**(-3./2.) + 2./3.*(p_GoB(x))**(-3./2.) )
        return theta
    
    def optimization(self):
        fmin(self.debye_T, 100)
        return